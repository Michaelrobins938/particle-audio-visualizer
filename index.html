<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiobook Narrator Orb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #333;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            color: #00FFFF;
            display: block;
            margin-bottom: 8px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }
        
        input[type="file"] {
            color: #fff;
            background: #111;
            border: 2px solid #00FFFF;
            padding: 10px;
            border-radius: 8px;
            width: 280px;
            transition: all 0.3s ease;
        }
        
        input[type="file"]:hover {
            border-color: #FF0055;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        button {
            background: linear-gradient(135deg, #00FFFF, #FF0055);
            border: none;
            color: #000;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 0, 85, 0.4);
            background: linear-gradient(135deg, #FF0055, #FF6600);
        }
        
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #info {
            color: #666;
            font-size: 10px;
            margin-top: 15px;
            line-height: 1.6;
        }
        
        #audioInfo {
            color: #00FF66;
            font-size: 12px;
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 255, 102, 0.1);
            border-radius: 8px;
            border: 1px solid #00FF66;
            display: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FFFF;
            font-size: 18px;
            z-index: 200;
            display: none;
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 255, 0.3);
            border-top: 3px solid #00FFFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <div class="control-group">
                <label for="audioFile">Audiobook File</label>
                <input type="file" id="audioFile" accept="audio/*,video/*">
            </div>
            
            <div class="control-group">
                <button id="playBtn" disabled>Play</button>
                <button id="pauseBtn" disabled>Pause</button>
                <button id="exportBtn" disabled>Export</button>
            </div>
            
            <div id="audioInfo">
                <div id="audioTitle">No file loaded</div>
                <div id="audioTime">00:00 / 00:00</div>
            </div>
            
            <div id="info">
                ðŸŽ§ Load your audiobook file<br>
                ðŸ”® Highly reactive narrator orb<br>
                ðŸ“¹ Export for video editing<br>
                ðŸ’« Sci-Fi HUD overlay included<br>
                <br>
                <strong>Hotkeys:</strong><br>
                Space: Play/Pause<br>
                E: Export Video
            </div>
        </div>
        
        <div id="loading">
            <div class="loading-spinner"></div>
            Processing audiobook...
        </div>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post-processing Effects - Fixed CDN URLs -->
    <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>

    <!-- Enhanced Perlin Noise Vertex Shader -->
    <script id="vertexshader" type="x-shader/x-vertex">
        uniform float time;
        uniform float amplitude;
        uniform float subBass;
        uniform float bass;
        uniform float lowMid;
        uniform float mid;
        uniform float highMid;
        uniform float presence;
        uniform float brilliance;
        uniform float reactivity;
        
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying float vDisplacement;
        varying float vFresnelFactor;
        varying float vSpeechActivity;
        
        // Simplified but effective Perlin noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
        }
        
        void main() {
            vPosition = position;
            vNormal = normal;
            
            vec3 pos = position;
            float timeSpeed = time * 0.8;
            
            // Enhanced organic noise foundation
            float noise1 = snoise(pos * 1.2 + vec3(timeSpeed * 0.3, timeSpeed * 0.2, 0.0));
            float noise2 = snoise(pos * 2.4 + vec3(0.0, timeSpeed * 0.4, timeSpeed * 0.5));
            float noise3 = snoise(pos * 4.8 + vec3(timeSpeed * 0.6, 0.0, timeSpeed * 0.3));
            
            // Combine base organic movement
            float baseOrganic = (noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1) * 0.15;
            
            // Enhanced speech-reactive displacement layers with noise integration
            float speechBase = snoise(pos * 1.8 + vec3(timeSpeed * 0.4, 0.0, 0.0)) * (bass + lowMid) * 0.3 * reactivity;
            speechBase += noise1 * (bass + lowMid) * 0.1 * reactivity;
            
            float vowelFormation = snoise(pos * 3.5 + vec3(0.0, timeSpeed * 0.8, timeSpeed * 0.6)) * mid * 0.25 * reactivity;
            vowelFormation += noise2 * mid * 0.08 * reactivity;
            
            float consonantDetail = snoise(pos * 8.0 + vec3(timeSpeed * 1.5, 0.0, timeSpeed * 1.2)) * (highMid + presence) * 0.18 * reactivity;
            consonantDetail += noise3 * (highMid + presence) * 0.06 * reactivity;
            
            float breathDetail = snoise(pos * 15.0 + vec3(timeSpeed * 2.0, timeSpeed * 1.8, 0.0)) * brilliance * 0.12 * reactivity;
            
            // Frequency-driven noise modulation as requested
            float u_frequency = (bass + lowMid + mid + highMid + presence + brilliance) * 10.0;
            float noise = noise1 + noise2 + noise3;
            
            // Combined displacement using the requested formula pattern
            float freqNoiseDisplacement = (u_frequency / 30.0) * (noise / 10.0);
            float speechDisplacement = (lowMid + mid + presence) * 0.25 * reactivity;
            
            // Total displacement combining all layers
            float totalDisplacement = baseOrganic + speechBase + vowelFormation + consonantDetail + breathDetail + freqNoiseDisplacement + speechDisplacement;
            
            // Global speech activity and pulsation
            float speechIntensity = (bass + lowMid + mid + highMid + presence) * 0.2;
            vSpeechActivity = speechIntensity;
            vDisplacement = totalDisplacement;
            
            float globalPulse = 1.0 + amplitude * 0.35 * reactivity;
            
            // Apply displacement along normal with enhanced organic movement
            vec3 displaced = pos + normal * totalDisplacement;
            displaced *= globalPulse;
            
            // Add subtle organic warping to the entire form
            displaced += noise1 * normal * 0.05;
            
            vWorldPosition = (modelMatrix * vec4(displaced, 1.0)).xyz;
            
            // Enhanced fresnel for refractive glass look
            vec4 worldPosition = modelMatrix * vec4(displaced, 1.0);
            vec3 worldNormal = normalize(normalMatrix * normal);
            vec3 viewDirection = normalize(cameraPosition - worldPosition.xyz);
            vFresnelFactor = pow(1.0 - abs(dot(viewDirection, worldNormal)), 2.2);
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragmentshader" type="x-shader/x-fragment">
        uniform float time;
        uniform float amplitude;
        uniform float mid;
        uniform float highMid;
        uniform float presence;
        uniform vec3 electricBlue;
        uniform vec3 scorchedPink;
        uniform vec3 ultravioletOrange;
        uniform vec3 toxicGreen;
        
        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        varying float vDisplacement;
        varying float vFresnelFactor;
        varying float vSpeechActivity;
        
        void main() {
            // Dynamic color mixing based on speech frequencies
            float colorCycle = sin(time * 0.8) * 0.5 + 0.5;
            float speechColorShift = vSpeechActivity * 2.0;
            
            // Base glass color with enhanced luminosity for bloom
            vec3 glassBase = mix(electricBlue, scorchedPink, colorCycle);
            
            // Speech-reactive color layers with bloom enhancement
            vec3 midColor = mix(glassBase, ultravioletOrange, mid * 0.8);
            vec3 finalColor = mix(midColor, toxicGreen, (highMid + presence) * 0.6);
            
            // Enhanced internal energy patterns for bloom
            float internalEnergy = abs(vDisplacement) * 4.0 + vSpeechActivity * 1.5;
            
            // Speech interference patterns with bloom contribution
            float speechPattern = sin(vPosition.x * 20.0 + time * 4.0) * 
                                cos(vPosition.y * 15.0 + time * 3.0) * 
                                sin(vPosition.z * 25.0 + time * 5.0) * 
                                vSpeechActivity * 0.5;
            
            // Enhanced rim lighting for bloom effect
            float rimIntensity = vFresnelFactor * 3.5;
            
            // Bloom-optimized lighting combination
            vec3 result = finalColor * (0.8 + internalEnergy + rimIntensity + abs(speechPattern));
            
            // Boost brightness for better bloom effect
            result *= 1.4;
            
            // Dynamic transparency with bloom consideration
            float alpha = 0.3 + rimIntensity * 0.6 + vSpeechActivity * 0.4;
            alpha += abs(speechPattern) * 0.25;
            alpha = clamp(alpha, 0.25, 0.95);
            
            gl_FragColor = vec4(result, alpha);
        }
    </script>

    <script type="module" src="hudShader.js"></script>
    <script type="module" src="main.js"></script>
</body>
</html>
